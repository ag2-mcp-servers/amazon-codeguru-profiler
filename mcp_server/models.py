# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T10:12:15+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, confloat, conint, constr


class ActionGroup(Enum):
    agentPermissions = 'agentPermissions'


class AgentParameterField(Enum):
    SamplingIntervalInMilliseconds = 'SamplingIntervalInMilliseconds'
    ReportingIntervalInMilliseconds = 'ReportingIntervalInMilliseconds'
    MinimumTimeForReportingInMilliseconds = 'MinimumTimeForReportingInMilliseconds'
    MemoryUsageLimitPercent = 'MemoryUsageLimitPercent'
    MaxStackDepth = 'MaxStackDepth'


class AgentProfile(RootModel[str]):
    root: str


class AggregatedProfile(RootModel[str]):
    root: str


class AggregationPeriod(Enum):
    PT5M = 'PT5M'
    PT1H = 'PT1H'
    P1D = 'P1D'


class AnomalyInstanceId(
    RootModel[
        constr(pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}')
    ]
):
    root: constr(
        pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    )


class Boolean(RootModel[bool]):
    root: bool


class ChannelId(
    RootModel[
        constr(pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}')
    ]
):
    root: constr(
        pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    )


class ChannelUri(RootModel[str]):
    root: str = Field(
        ...,
        description='Channel URI uniquely identifies a Notification Channel. TopicArn is the uri for an SNS channel, emailId is uri for an email channel etc. Currently we only support SNS channels and thus required to be an ARN',
    )


class ClientToken(RootModel[constr(pattern=r'^[\w-]+$', min_length=1, max_length=64)]):
    root: constr(pattern=r'^[\w-]+$', min_length=1, max_length=64)


class ComputePlatform(Enum):
    Default = 'Default'
    AWSLambda = 'AWSLambda'


class ConflictException(RootModel[Any]):
    root: Any


class DeleteProfilingGroupRequest(BaseModel):
    pass


class DeleteProfilingGroupResponse(BaseModel):
    pass


class DescribeProfilingGroupRequest(BaseModel):
    pass


class Double(RootModel[float]):
    root: float


class EventPublisher(Enum):
    AnomalyDetection = 'AnomalyDetection'


class EventPublishers(RootModel[List[EventPublisher]]):
    root: List[EventPublisher] = Field(..., max_length=1, min_length=1)


class FeedbackType(Enum):
    Positive = 'Positive'
    Negative = 'Negative'


class FindingsReportId(
    RootModel[
        constr(pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}')
    ]
):
    root: constr(
        pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    )


class FleetInstanceId(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class FrameMetricValue(RootModel[float]):
    root: float


class FrameMetricValues(RootModel[List[FrameMetricValue]]):
    root: List[FrameMetricValue]


class GetFindingsReportAccountSummaryRequest(BaseModel):
    pass


class GetNotificationConfigurationRequest(BaseModel):
    pass


class GetPolicyRequest(BaseModel):
    pass


class GetProfileRequest(BaseModel):
    pass


class GetProfileResponse(BaseModel):
    profile: AggregatedProfile


class GetRecommendationsRequest(BaseModel):
    pass


class Integer(RootModel[int]):
    root: int


class InternalServerException(RootModel[Any]):
    root: Any


class ListFindingsReportsRequest(BaseModel):
    pass


class ListProfileTimesRequest(BaseModel):
    pass


class ListProfilingGroupsRequest(BaseModel):
    pass


class ListTagsForResourceRequest(BaseModel):
    pass


class Locale(RootModel[str]):
    root: str = Field(
        ...,
        description='BCP47 language code. Supported locales: de-DE, en-GB, en-US, es-ES, fr-FR, it-IT, ja-JP, ko-KR, pt-BR, zh-CN, zh-TW',
    )


class MaxDepth(RootModel[conint(ge=1, le=10000)]):
    root: conint(ge=1, le=10000)


class MaxResults(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class MetadataField(Enum):
    ComputePlatform = 'ComputePlatform'
    AgentId = 'AgentId'
    AwsRequestId = 'AwsRequestId'
    ExecutionEnvironment = 'ExecutionEnvironment'
    LambdaFunctionArn = 'LambdaFunctionArn'
    LambdaMemoryLimitInMB = 'LambdaMemoryLimitInMB'
    LambdaRemainingTimeInMilliseconds = 'LambdaRemainingTimeInMilliseconds'
    LambdaTimeGapBetweenInvokesInMilliseconds = (
        'LambdaTimeGapBetweenInvokesInMilliseconds'
    )
    LambdaPreviousExecutionTimeInMilliseconds = (
        'LambdaPreviousExecutionTimeInMilliseconds'
    )


class MetricType(Enum):
    AggregatedRelativeTotalTime = 'AggregatedRelativeTotalTime'


class OrderBy(Enum):
    TimestampDescending = 'TimestampDescending'
    TimestampAscending = 'TimestampAscending'


class PaginationToken(
    RootModel[constr(pattern=r'^[\w-]+$', min_length=1, max_length=64)]
):
    root: constr(pattern=r'^[\w-]+$', min_length=1, max_length=64)


class Percentage(RootModel[confloat(ge=0.0, le=100.0)]):
    root: confloat(ge=0.0, le=100.0)


class Period(RootModel[constr(min_length=1, max_length=64)]):
    root: constr(min_length=1, max_length=64)


class PostAgentProfileRequest(BaseModel):
    agentProfile: AgentProfile


class PostAgentProfileResponse(BaseModel):
    pass


class Principal(RootModel[str]):
    root: str


class Principals(RootModel[List[Principal]]):
    root: List[Principal] = Field(..., max_length=50, min_length=1)


class ProfilingGroupArn(RootModel[str]):
    root: str


class ProfilingGroupName(
    RootModel[constr(pattern=r'^[\w-]+$', min_length=1, max_length=255)]
):
    root: constr(pattern=r'^[\w-]+$', min_length=1, max_length=255)


class ProfilingGroupNames(RootModel[List[ProfilingGroupName]]):
    root: List[ProfilingGroupName]


class RemoveNotificationChannelRequest(BaseModel):
    pass


class RemovePermissionRequest(BaseModel):
    pass


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class RevisionId(
    RootModel[
        constr(pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}')
    ]
):
    root: constr(
        pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    )


class ServiceQuotaExceededException(RootModel[Any]):
    root: Any


class String(RootModel[str]):
    root: str


class Strings(RootModel[List[String]]):
    root: List[String]


class SubmitFeedbackRequest(BaseModel):
    comment: Optional[String] = None
    type: FeedbackType


class SubmitFeedbackResponse(BaseModel):
    pass


class TagKeys(RootModel[List[String]]):
    root: List[String]


class TagResourceResponse(BaseModel):
    pass


class TagsMap(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class TargetFrame(RootModel[List[String]]):
    root: List[String]


class TargetFrames(RootModel[List[TargetFrame]]):
    root: List[TargetFrame]


class ThreadStates(RootModel[List[String]]):
    root: List[String]


class ThrottlingException(RootModel[Any]):
    root: Any


class Timestamp(RootModel[datetime]):
    root: datetime


class TimestampStructure(BaseModel):
    value: Timestamp


class UntagResourceRequest(BaseModel):
    pass


class UntagResourceResponse(BaseModel):
    pass


class UserFeedback(BaseModel):
    type: FeedbackType


class ValidationException(RootModel[Any]):
    root: Any


class Type(Enum):
    Positive = 'Positive'
    Negative = 'Negative'


class InternalProfilingGroupsProfilingGroupNameAnomaliesAnomalyInstanceIdFeedbackPostRequest(
    BaseModel
):
    comment: Optional[str] = Field(
        None, description='Optional feedback about this anomaly.'
    )
    type: Type = Field(
        ...,
        description=' The feedback tpye. Thee are two valid values, <code>Positive</code> and <code>Negative</code>. ',
    )


class AgentOrchestrationConfig1(BaseModel):
    profilingEnabled: Optional[Boolean] = None


class ProfilingGroupsClientTokenPostRequest(BaseModel):
    agentOrchestrationConfig: Optional[AgentOrchestrationConfig1] = Field(
        None,
        description=' Specifies whether profiling is enabled or disabled for a profiling group. It is used by <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html"> <code>ConfigureAgent</code> </a> to enable or disable profiling for a profiling group. ',
    )
    computePlatform: Optional[ComputePlatform] = Field(
        None,
        description=' The compute platform of the profiling group. Use <code>AWSLambda</code> if your application runs on AWS Lambda. Use <code>Default</code> if your application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform. If not specified, <code>Default</code> is used. ',
    )
    profilingGroupName: constr(pattern=r'^[\w-]+$', min_length=1, max_length=255) = (
        Field(..., description='The name of the profiling group to create.')
    )
    tags: Optional[Dict[str, String]] = Field(
        None, description=' A list of tags to add to the created profiling group. '
    )


class ProfilingGroupsProfilingGroupNamePutRequest(BaseModel):
    agentOrchestrationConfig: AgentOrchestrationConfig1 = Field(
        ...,
        description=' Specifies whether profiling is enabled or disabled for a profiling group. It is used by <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html"> <code>ConfigureAgent</code> </a> to enable or disable profiling for a profiling group. ',
    )


class ProfilingGroupsProfilingGroupNameAgentProfileContentTypePostRequest(BaseModel):
    agentProfile: str = Field(..., description=' The submitted profiling data. ')


class ProfilingGroupsProfilingGroupNameConfigureAgentPostRequest(BaseModel):
    fleetInstanceId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description=" A universally unique identifier (UUID) for a profiling instance. For example, if the profiling instance is an Amazon EC2 instance, it is the instance ID. If it is an AWS Fargate container, it is the container's task ID. ",
    )
    metadata: Optional[Dict[str, String]] = Field(
        None,
        description='<p> Metadata captured about the compute platform the agent is running on. It includes information about sampling and reporting. The valid fields are:</p> <ul> <li> <p> <code>COMPUTE_PLATFORM</code> - The compute platform on which the agent is running </p> </li> <li> <p> <code>AGENT_ID</code> - The ID for an agent instance. </p> </li> <li> <p> <code>AWS_REQUEST_ID</code> - The AWS request ID of a Lambda invocation. </p> </li> <li> <p> <code>EXECUTION_ENVIRONMENT</code> - The execution environment a Lambda function is running on. </p> </li> <li> <p> <code>LAMBDA_FUNCTION_ARN</code> - The Amazon Resource Name (ARN) that is used to invoke a Lambda function. </p> </li> <li> <p> <code>LAMBDA_MEMORY_LIMIT_IN_MB</code> - The memory allocated to a Lambda function. </p> </li> <li> <p> <code>LAMBDA_REMAINING_TIME_IN_MILLISECONDS</code> - The time in milliseconds before execution of a Lambda function times out. </p> </li> <li> <p> <code>LAMBDA_TIME_GAP_BETWEEN_INVOKES_IN_MILLISECONDS</code> - The time in milliseconds between two invocations of a Lambda function. </p> </li> <li> <p> <code>LAMBDA_PREVIOUS_EXECUTION_TIME_IN_MILLISECONDS</code> - The time in milliseconds for the previous Lambda invocation. </p> </li> </ul>',
    )


class TargetResolution(Enum):
    PT5M = 'PT5M'
    PT1H = 'PT1H'
    P1D = 'P1D'


class ProfilingGroupsProfilingGroupNamePolicyActionGroupPutRequest(BaseModel):
    principals: List[Principal] = Field(
        ...,
        description=' A list ARNs for the roles and users you want to grant access to the profiling group. Wildcards are not are supported in the ARNs. ',
        max_length=50,
        min_length=1,
    )
    revisionId: Optional[
        constr(pattern=r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}')
    ] = Field(
        None,
        description=' A universally unique identifier (UUID) for the revision of the policy you are adding to the profiling group. Do not specify this when you add permissions to a profiling group for the first time. If a policy already exists on the profiling group, you must specify the <code>revisionId</code>. ',
    )


class Period1(Enum):
    PT5M = 'PT5M'
    PT1H = 'PT1H'
    P1D = 'P1D'


class TagsResourceArnPostRequest(BaseModel):
    tags: Dict[str, String] = Field(
        ..., description=' The list of tags that are added to the specified resource. '
    )


class AgentOrchestrationConfig(BaseModel):
    profilingEnabled: Boolean


class AgentParameters(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class AggregatedProfileTime(BaseModel):
    period: Optional[AggregationPeriod] = None
    start: Optional[Timestamp] = None


class AnomalyInstance(BaseModel):
    endTime: Optional[Timestamp] = None
    id: String
    startTime: Timestamp
    userFeedback: Optional[UserFeedback] = None


class AnomalyInstances(RootModel[List[AnomalyInstance]]):
    root: List[AnomalyInstance]


class Channel(BaseModel):
    eventPublishers: EventPublishers
    id: Optional[ChannelId] = None
    uri: ChannelUri


class Channels(RootModel[List[Channel]]):
    root: List[Channel] = Field(..., max_length=2, min_length=1)


class CreateProfilingGroupRequest(BaseModel):
    agentOrchestrationConfig: Optional[AgentOrchestrationConfig] = None
    computePlatform: Optional[ComputePlatform] = None
    profilingGroupName: ProfilingGroupName
    tags: Optional[TagsMap] = None


class FindingsReportSummary(BaseModel):
    id: Optional[FindingsReportId] = None
    profileEndTime: Optional[Timestamp] = None
    profileStartTime: Optional[Timestamp] = None
    profilingGroupName: Optional[String] = None
    totalNumberOfFindings: Optional[Integer] = None


class FrameMetric(BaseModel):
    frameName: String
    threadStates: ThreadStates
    type: MetricType


class FrameMetricDatum(BaseModel):
    frameMetric: FrameMetric
    values: FrameMetricValues


class FrameMetrics(RootModel[List[FrameMetric]]):
    root: List[FrameMetric]


class GetPolicyResponse(BaseModel):
    policy: String
    revisionId: RevisionId


class ListOfTimestamps(RootModel[List[TimestampStructure]]):
    root: List[TimestampStructure]


class ListTagsForResourceResponse(BaseModel):
    tags: Optional[TagsMap] = None


class Match(BaseModel):
    frameAddress: Optional[String] = None
    targetFramesIndex: Optional[Integer] = None
    thresholdBreachValue: Optional[Double] = None


class Matches(RootModel[List[Match]]):
    root: List[Match]


class Metadata(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class Metric(BaseModel):
    frameName: String
    threadStates: Strings
    type: MetricType


class NotificationConfiguration(BaseModel):
    channels: Optional[Channels] = None


class Pattern(BaseModel):
    countersToAggregate: Optional[Strings] = None
    description: Optional[String] = None
    id: Optional[String] = None
    name: Optional[String] = None
    resolutionSteps: Optional[String] = None
    targetFrames: Optional[TargetFrames] = None
    thresholdPercent: Optional[Percentage] = None


class ProfileTime(BaseModel):
    start: Optional[Timestamp] = None


class ProfileTimes(RootModel[List[ProfileTime]]):
    root: List[ProfileTime]


class ProfilingStatus(BaseModel):
    latestAgentOrchestratedAt: Optional[Timestamp] = None
    latestAgentProfileReportedAt: Optional[Timestamp] = None
    latestAggregatedProfile: Optional[AggregatedProfileTime] = None


class PutPermissionRequest(BaseModel):
    principals: Principals
    revisionId: Optional[RevisionId] = None


class PutPermissionResponse(BaseModel):
    policy: String
    revisionId: RevisionId


class Recommendation(BaseModel):
    allMatchesCount: Integer
    allMatchesSum: Double
    endTime: Timestamp
    pattern: Pattern
    startTime: Timestamp
    topMatches: Matches


class Recommendations(RootModel[List[Recommendation]]):
    root: List[Recommendation]


class RemoveNotificationChannelResponse(BaseModel):
    notificationConfiguration: Optional[NotificationConfiguration] = None


class RemovePermissionResponse(BaseModel):
    policy: String
    revisionId: RevisionId


class TagResourceRequest(BaseModel):
    tags: TagsMap


class UnprocessedEndTimeMap(RootModel[Optional[Dict[str, ListOfTimestamps]]]):
    root: Optional[Dict[str, ListOfTimestamps]] = None


class UpdateProfilingGroupRequest(BaseModel):
    agentOrchestrationConfig: AgentOrchestrationConfig


class ProfilingGroupsProfilingGroupNameFramesMetricsPostRequest(BaseModel):
    frameMetrics: Optional[List[FrameMetric]] = Field(
        None,
        description=' The details of the metrics that are used to request a time series of values. The metric includes the name of the frame, the aggregation type to calculate the metric value for the frame, and the thread states to use to get the count for the metric value of the frame.',
    )


class ProfilingGroupsProfilingGroupNameNotificationConfigurationPostRequest(BaseModel):
    channels: List[Channel] = Field(
        ...,
        description='One or 2 channels to report to when anomalies are detected.',
        max_length=2,
        min_length=1,
    )


class AddNotificationChannelsRequest(BaseModel):
    channels: Channels


class AddNotificationChannelsResponse(BaseModel):
    notificationConfiguration: Optional[NotificationConfiguration] = None


class AgentConfiguration(BaseModel):
    agentParameters: Optional[AgentParameters] = None
    periodInSeconds: Integer
    shouldProfile: Boolean


class Anomaly(BaseModel):
    instances: AnomalyInstances
    metric: Metric
    reason: String


class BatchGetFrameMetricDataRequest(BaseModel):
    frameMetrics: Optional[FrameMetrics] = None


class ConfigureAgentRequest(BaseModel):
    fleetInstanceId: Optional[FleetInstanceId] = None
    metadata: Optional[Metadata] = None


class ConfigureAgentResponse(BaseModel):
    configuration: AgentConfiguration


class FindingsReportSummaries(RootModel[List[FindingsReportSummary]]):
    root: List[FindingsReportSummary]


class FrameMetricData(RootModel[List[FrameMetricDatum]]):
    root: List[FrameMetricDatum]


class GetFindingsReportAccountSummaryResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    reportSummaries: FindingsReportSummaries


class GetNotificationConfigurationResponse(BaseModel):
    notificationConfiguration: NotificationConfiguration


class ListFindingsReportsResponse(BaseModel):
    findingsReportSummaries: FindingsReportSummaries
    nextToken: Optional[PaginationToken] = None


class ListProfileTimesResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    profileTimes: ProfileTimes


class ProfilingGroupDescription(BaseModel):
    agentOrchestrationConfig: Optional[AgentOrchestrationConfig] = None
    arn: Optional[ProfilingGroupArn] = None
    computePlatform: Optional[ComputePlatform] = None
    createdAt: Optional[Timestamp] = None
    name: Optional[ProfilingGroupName] = None
    profilingStatus: Optional[ProfilingStatus] = None
    tags: Optional[TagsMap] = None
    updatedAt: Optional[Timestamp] = None


class ProfilingGroupDescriptions(RootModel[List[ProfilingGroupDescription]]):
    root: List[ProfilingGroupDescription]


class UpdateProfilingGroupResponse(BaseModel):
    profilingGroup: ProfilingGroupDescription


class Anomalies(RootModel[List[Anomaly]]):
    root: List[Anomaly]


class BatchGetFrameMetricDataResponse(BaseModel):
    endTime: Timestamp
    endTimes: ListOfTimestamps
    frameMetricData: FrameMetricData
    resolution: AggregationPeriod
    startTime: Timestamp
    unprocessedEndTimes: UnprocessedEndTimeMap


class CreateProfilingGroupResponse(BaseModel):
    profilingGroup: ProfilingGroupDescription


class DescribeProfilingGroupResponse(BaseModel):
    profilingGroup: ProfilingGroupDescription


class GetRecommendationsResponse(BaseModel):
    anomalies: Anomalies
    profileEndTime: Timestamp
    profileStartTime: Timestamp
    profilingGroupName: ProfilingGroupName
    recommendations: Recommendations


class ListProfilingGroupsResponse(BaseModel):
    nextToken: Optional[PaginationToken] = None
    profilingGroupNames: ProfilingGroupNames
    profilingGroups: Optional[ProfilingGroupDescriptions] = None
